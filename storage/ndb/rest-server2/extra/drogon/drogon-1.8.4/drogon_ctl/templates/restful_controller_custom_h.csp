<%inc#include "create_model.h"
using namespace drogon_ctl;
%>
/**
 *
 *  [[fileName]].h
 *  This file is generated by drogon_ctl
 *
 */

#pragma once

#include <drogon/HttpController.h>
#include "[[className]]Base.h"

<%c++
auto tableInfo = @@.get<DrTemplateData>("tableInfo");
auto modelName = tableInfo.get<std::string>("className");
$$<<"#include \""<<modelName<<".h\"\n";
bool hasPrimaryKey = (tableInfo.get<int>("hasPrimaryKey")==1);
$$<<"using namespace drogon;\n";

$$<<"using namespace drogon_model::"<<tableInfo.get<std::string>("dbName");
auto &schema=tableInfo.get<std::string>("schema");
if(!schema.empty())
{
    $$<<"::"<<schema<<";\n";
}
else
{
    $$<<";\n";
}

auto namespaceVector=@@.get<std::vector<std::string>>("namespaceVector");
for(auto &name:namespaceVector)
{
%>
namespace {%name%} 
{
<%c++}%>
/**
 * @brief this class is created by the drogon_ctl command.
 * this class is a restful API controller for reading and writing the [[tableName]] table.
 */

class [[className]]: public drogon::HttpController<[[className]]>, public [[className]]Base
{
  public:
    METHOD_LIST_BEGIN
<%c++
auto resource=@@.get<std::string>("resource");
if(resource.empty())
{    
    if(hasPrimaryKey)
    {
%>
    METHOD_ADD([[className]]::getOne,"/{1}",Get,Options[[filters]]);
    METHOD_ADD([[className]]::updateOne,"/{1}",Put,Options[[filters]]);
    METHOD_ADD([[className]]::deleteOne,"/{1}",Delete,Options[[filters]]);
<%c++}%>
    METHOD_ADD([[className]]::get,"",Get,Options[[filters]]);
    METHOD_ADD([[className]]::create,"",Post,Options[[filters]]);
    //METHOD_ADD([[className]]::update,"",Put,Options[[filters]]);
<%c++
}else
{
    if(hasPrimaryKey)
    {
%>
    ADD_METHOD_TO([[className]]::getOne,"{%resource%}/{1}",Get,Options[[filters]]);
    ADD_METHOD_TO([[className]]::updateOne,"{%resource%}/{1}",Put,Options[[filters]]);
    ADD_METHOD_TO([[className]]::deleteOne,"{%resource%}/{1}",Delete,Options[[filters]]);
<%c++}%>
    ADD_METHOD_TO([[className]]::get,"{%resource%}",Get,Options[[filters]]);
    ADD_METHOD_TO([[className]]::create,"{%resource%}",Post,Options[[filters]]);
    //ADD_METHOD_TO([[className]]::update,"{%resource%}",Put,Options[[filters]]);
<%c++}%>
    METHOD_LIST_END
     
<%c++if(hasPrimaryKey)
{
%>
    void getOne(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback,
                {%modelName%}::PrimaryKeyType &&id);
    void updateOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
    void deleteOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
<%c++}
%>
    void get(const HttpRequestPtr &req,
             std::function<void(const HttpResponsePtr &)> &&callback);
    void create(const HttpRequestPtr &req,
             std::function<void(const HttpResponsePtr &)> &&callback);

};
<%c++ for(size_t i=0;i<namespaceVector.size();++i)
{
    $$<<"}\n";
}
%>